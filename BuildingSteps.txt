===== Lexer (Лексический анализатор / Токенизатор) =====
1. Вводные данные:
	Строка (String) задающая регулярное выражение.
2. Выходные данные:
	Объект класса TokenStream (поток токенов)
3. Видимые классы в пакете:
	Token
	TokenType
	TokenStream
	Lexer
4. Использование:
	TokenStream tokenStream = Lexer.parse("a[bc]*d");
5. Дополнительная информация:
		Получает на вход строку, перебирает его посимвольно и каждому символу задает соответствие с каким-нибудь токеном.

===== Parser (Синтаксический анализатор / Парсер) =====
1. Вводные данные: 
	Поток токенов (TokenStream)
2. Выходные данные:
	Синтаксическое дерево (SyntaxTree)
3. Видимые классы в пакете
	package syntax_tree
		SyntaxTree
		Element
		Node
		Leaf
	Parser
4. Использование:
	SyntaxTree syntaxTree = Parser.parse(tokenStream);
5. Дополнительная информация:
		Получает поток токенов, и используя стек состояний, строит синтаксическое дерево.

===== SemanticModelBuilder (Строитель семантической модели / транслятор в модель) ======
1. Вводные данные:
	Синтаксическое дерево (SyntaxTree)
2. Выходные данные:
	Семантическая модель (SemanticModel)
3. Видимые классы в пакете:
	SemanticModel
	SemanticModelBuilder
4. Использование:
	SemanticModel model = SemanticModelBuilder.build(syntaxTree);
5. Дополнительная информация:
		Получает синтаксическое дерево. 
		Применяет к ним правила преобразования синтаксического дерева в семантическую модель
		И создает объект семантической модели (возвращает корневой элемент (Sequence))

===== DomModelRegularExpressionBuilder ===== [Facade]
1. Вводные данные:
	Строка (String) регулярного выражения
2. Выходные данные:
	Объект регулярного выражения (DomModelRegularExpression)
3. Видимые классы:
	DomModelRegularExpression
4. Использование:
	DomModelRegularExpression regexp = DomModelRegularExpressionBuilder.build("a[bc]*d");
5. Дополнительная информация:
		Выполняет все шаги по созданию регулярного выражения на основе семантической DOM-модели.
		Фасад для простого создания регулярного выражения.
